Соболев Олег Вадимович sobolev_ov@mail.ru

> Colorless green ideas sleep furiously - (c) Ноам Хомский

Естественные языки - то, что родилось в процессе (р)эволюции

# Что предложил Хомский
Терминальные символы (множество терминальных символов - VT) 
Можем строить из них цепочки - предложения.

Набор зависит от уровня грамматики, который мы рассматриваем. (В примерах терминальные символы - a, b, c)

```c
int count = 10;
```

`int`, `count`, `=`, `10`, `;` - лексемы 

Терминальные символы - элементарные символы языка.

Есть множество `VT*` - по научному замыкание линий.

`VT={a,b,c}` `VT*={(эпсилон - цепочка длинны 0), a, b, c, aa, ab, ...` - множество цепочек всех длин

Язык L - подмножество всех замыканий. `L ⊂ VT*` `x ∈ VT*` `x ∈ L?`


Нетерминальные символы (VN) <A>

`S ∈ VN` - стартовый символ

P - правила вывода

`Цепочка из VT ∪ VN ::= цепочка из VT ∪ VN`
**Хотя бы один из VN**


`G = {VT, VN, S, P}`

Пример: `a<A>bc`

# Как проверить, что цепочка правильна?

`L(G) = {множество всех цепочек, получаемых по правилам P}.`

## Пример:

### Объявляем правила 

VT = {0, 1}, VN={<число>} S = <число>

1. <число> ::= 0
2. <число> ::= 1
3. <число> ::= <число> 0
4. <число> ::= <число> 1

### Процесс составления цепочки

<число> -3→ <число> 0 -4→ <число> 10 -2→ 110. Цепочка грамматически правильная.

## Пример 2:

### Об

Числа, которые всегда не начинается с 0.

VT = {0, 1}, VN={<число>, <1число>} S = <1число>

1. <число> ::= 0
2. <число> ::= 1
3. <число> ::= <число> 0
4. <число> ::= <число> 1
5. <1число> ::= 1<число>
6. <1число> ::= 1

### Процесс составления цепочки
 <1число> -5→ 1< x<число> -3→ 1<число>0 -1→ 100
 
# Иерархия языка

## Контекстно-свободные грамматики 
(КС-грамматики)
Context-free grammar
`<x> ::= цепочка VT ∪ NV`
Слева - только один нетерминальный символ

## Контекстно-зависимые грамматики 
(КЗ-грамматики)
Context-sensitive

`a<A>b ::= b<A>a`
Нет ограничений на левую часть

### Пример

`S → ... → aba<A>bb<A> → abb<A>ab<A>

## Регулярные грамматики

### Леворегулярные грамматики

Цепочка, которая стоит в правый части может содержать нетерминальный символ только слева:  `<A>::=<B>abc`
`<A> ::= abc<B>` - так нельзя, толко в праворегулярной грамматике.

### Пример праворегулярной грамматики

```c
void f() {
	x = x + 1; // a <A> ::= abc<A>
	y = y + 2; // b
	f();
}
```

```c
void f() {
	while(1) {
		x = x + 1; 
		y = y + 2; 
	}
}
```

Гедель, Эдер, Бах - о рекурсии и циклах

 https://yadi.sk/i/UzwyLm6YgmlAkA
 
# Вторая практика
 
# Лексический анализ
 
## Лексемы/token
 
 `int` `<пробел> ` `x5` `+=` `y18` `+` `645` `;` - всё лексемы.
 
## Правила для примера
VT = {0, 1, ..., 9,  .}
 
VN = {<число>, <цифра>, <др. число>}
 
S = <др.число>
 
1. <цифра> ::= 0
2. <цифра> ::= 1
 
...
 
10. <цифра> ::= 9
11. <число> ::= <цифра>
12. <число> ::= <число><цифра>
 
### Пример цепочки вывода
<число> -12→ **<число>**<цифра> -12→ **<число>**<цифра><цифра> -11→ **<цифра>**<цифра><цифра> -2→ 1<цифра><цифра> -9→ 19<цифра> -1→ 190.
 
БНФ - Нормальная форма Бэкуса
 
Благодаря этому правилу можно объединить правила 1-10. Получится <цифра> ::= 0|1|...|8|9 [правило 1]. Получается метасимвол. 

11-12 также можно объединить в <число> ::= <цифра> | <число><цифра> [правило 2]
 
### Обновлённые правила
 
1. <цифра> ::= 0|1|...|8|9
2. <число> ::= <цифра> | <число><цифра>
3. <др. число> ::= <число>.<число> | <число>. | .<число> 

### Примеры правильных и неправильных идентификаторов

- Правильно: `xy511`, `x`, `x_5`, `_1`, `_`;

- Неправильно: `1z`, `12`.

#### Придумываем правила для идентификаторов

VT = {a, b, ..., z, A, B, ..., Z, 0, 1, ... 9}

VN = {<ид>}

S = <ид>

P:
1. <буква> ::= a|b|...|z|A|B|..|Z|_
2. <цифра> ::= 0|1|...|9
3. <ид> ::= <буква>
4. <ид> ::= <ид><буква>
5. <ид> ::= <ид><цфира>

РБНФ - расширенная нормальная форма Бэкуса

- <цифра>+ ≥ 1 раза
- <цифра>* или {<цфира>}: ≥ 0 раз
- <цифра>? или [<цфира>]: 0 или 1 раз

3-5 → [3] <ид> ::= <буква>(<буква> | <цифра>)*

#### Абстрактный пример рекурсии

```
<x> ::= <y>*
		↑ ↓
<x> ::= ε
<x> ::= <x><y>
```

### Вернулись к регулярной грамматике

\<x> ::= abc<y>

\<y> ::= de<x>

\<x> ::= ε

---
\<x> ::= abcde<x>

\<x> ::= ε

---
\<y> ::= abcde

\<x> ::= <y>*

---
\<x> ::= (abcde)*

## Пишем программку

### Референс к правилам
[a-z] - все символы от `a` до `z`

Аналогично с [A-Z]

[A-Za-z_] = <буква>

[0-9]


# Грамматика

`+ * ? ( ) |`

VT = {...}

VN = {\<S>}

P: \<S> ::= ... - VT + мета-символы = регулярные выражение

[https://yadi.sk/i/ZV5nWneKtfhcMg]

# Пример лексического анализатора

15 * (3 + 2) - x

1 + 2

10++ - выражение неправильное

## Разбивание текста не лексемы

```
10+20
↑
```

1. NUMBER, "10"

```
10+20
  ↑
```

2. ADD, "+"

```
10+20
   ↑
```

3. NUMBER, "20"

```java
enum TokenType {
	NUMBER("<...>"),
	ID("<...>"),
	ADD("\\+"),
	SUB("-"),
	MUL("\\*"),
	DIV("/"),
	LPAR("\\("),
	RPAR("\\)"),
	SPACE("[ \t\r\n]+"); // \r - для Windows.
	Pattern pattern;
	
	TokenType(String regexp) {
		pattern = Pattern.compile(regexp);
	} 
}

class Token {
	TokenType type;
	String text;
	int index;
	
	<конструктор>
}

class Lexer {
	String src;
	int pos = 0;
	List<Token> tokens = new ArrayList<>();
	boolean nextToken() {
		if (pos >= src.length()) {
			return false;
		}
		
		for (TokenType tt: TokenType.values()) {
			Matcher m = tt.pattern.matcher(src);
			m.region(pos, src.length());
			
			if (m.lookingAt()) {
				Token t = new Token (tt, m.group(), pos);
				token add(t);
				pos = m.end();
				return true;
			}
		}
		throw new RuntimeException("Неизвестный символ");
	}
	
	Lit<Token> lex() {
		while (nextToken()) {
		}
		return tokens;
	}
	
	private static void main() {
		String text = "10 + 20";
		Lexer l = new Lexer(text);
		List<Token> tlist = l.lex(); 
		for (Token t: tlist) {
			 System.out.print(t.type + " " + t.text);
		}
	}
}
```

# Реализация конечного автомата
  
## Лексика
VT = {ASCII}; <выражение> = (<цифра>(<буква>|<цифра>)+|`+`|`-`|`*`|`/`|`(`|`)`|`<пробел>`+)*

## Грамматика

VT = {число, ид, `+`, `-`, `*`, `/`, `(`, `)`}

<выражение> ::= число(`+` число)*

1. <П> ::= a ->O-a→(O)
2. <П> ::= <П1><П2> пересечение П1 с П2
3. <П> ::= <П1>|<П2> объединение
4. <П> ::= <П1>*

[https://yadi.sk/i/PylCkteZuT84bA] -> [https://yadi.sk/d/FwCG_yOepvxGfw]


S   | число    | +
----|----------|------
S_0 | S_2, S_5 | -
S_2 | -        | S_3
S_3 | S_2, S_5 | -
S_5 | -        | -


 S    | число | +
------|-------|---
S_0   | S_2,5 | -
S_1   | S_2,5 | -
S_2,5 | -     | S_3

https://yadi.sk/i/B8kI4RpU4I48PQ

```java
enum State {
	S_0, S_FINAL, S_LOOP
}
class Parser {
	Token[] tokens; //char[] symbols;
	int pos = 0;
	
	Parser(tokens, pos) { //Parser(symbols, pos) {
		this.tokens = tokens; //this.symbols = symbols;
		this.pos = pos;
	}
	
	void error(String message) {
		throw new RuntimeException(message + " at " + pos);
	}
	
	boolean match(char expected) {
		if (pos < symbols.length) {
			char ch = symbols[pos];
			if (ch == expected) {
				pos++;
				return true;
			}
		}
		return false;
	}
	
	State newState(State s) {
		switch (s) {
			case S_0:
			case S_LOOP:
				if (match('4')) {
					return State.S_FINAL;
				}
				error("Ожидаось Число");
			case S_FINAL:
				if (match('+')) {
					return State.S_LOOP;
				}
				error("Ожидался +");
		}
	}
	
	boolean parse() { // boolean run() {
		State s = State.S_0;
		while (pos < symbols.length) {
			s = newState(s);
		}
		return s == State.S_FINAL;
	}
	
	void runz() {
		require('ч');
		while (pos < symbols.length) {
			require('+');
			require('ч');
		}
	}
	
	void requre(char c) {
		if (!match(c)) {
			error("Ожидался " + с)ж
		}
}

public static void main ( {
	String text = "4+4";
	Parser p = new Parser(text.toCharArray());
	boolean ok = p.run();
	System.out.print(ok);
}
					
	
```


# Практика 3

<выражение> ::= число ('+', число)*

---

1. <выражение> ::= число
2. <выражение> ::= число '+' <выражение>

<выражение> -2→ число '+' <выражение> -2→ число '+' число '+' <выражение> -1→ число + число + число

Дерево разбора:
https://yadi.sk/i/NAk1u__W-OiT1g 

## Пример

<цифра> :: = 0..9

<число> ::= <цифра>

<число> ::= <число><цифра>

У примера такое же дерево, как и выше только с цифрой и числом.

В компиляторах не используют дерево разбора. Используют AST (Abstract Syntax Tree) Абстрактное синтаксическое дерево (модифицированное дерево разбора)

Пример AST для [этого](#Практика 3) дерева разбора: https://yadi.sk/i/gAOXrisirH8JNw


((^n))^n n ≥ 0

<скобки> ::= ε
<скобки> :: '(' <скобки> ')'

