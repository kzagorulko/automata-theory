Соболев Олег Вадимович sobolev_ov@mail.ru

> Colorless green ideas sleep furiously - (c) Ноам Хомский

Естественные языки - то, что родилось в процессе (р)эволюции

# Что предложил Хомский
Терминальные символы (множество терминальных символов - VT) 
Можем строить из них цепочки - предложения.

Набор зависит от уровня грамматики, который мы рассматриваем. (В примерах терминальные символы - a, b, c)

```c
int count = 10;
```

`int`, `count`, `=`, `10`, `;` - лексемы 

Терминальные символы - элементарные символы языка.

Есть множество `VT*` - по научному замыкание линий.

`VT={a,b,c}` `VT*={(эпсилон - цепочка длинны 0), a, b, c, aa, ab, ...` - множество цепочек всех длин

Язык L - подмножество всех замыканий. `L ⊂ VT*` `x ∈ VT*` `x ∈ L?`


Нетерминальные символы (VN) <A>

`S ∈ VN` - стартовый символ

P - правила вывода

`Цепочка из VT ∪ VN ::= цепочка из VT ∪ VN`
**Хотя бы один из VN**


`G = {VT, VN, S, P}`

Пример: `a<A>bc`

# Как проверить, что цепочка правильна?

`L(G) = {множество всех цепочек, получаемых по правилам P}.`

## Пример:

### Объявляем правила 

VT = {0, 1}, VN={<число>} S = <число>

1. <число> ::= 0
2. <число> ::= 1
3. <число> ::= <число> 0
4. <число> ::= <число> 1

### Процесс составления цепочки

<число> -3→ <число> 0 -4→ <число> 10 -2→ 110. Цепочка грамматически правильная.

## Пример 2:

### Об

Числа, которые всегда не начинается с 0.

VT = {0, 1}, VN={<число>, <1число>} S = <1число>

1. <число> ::= 0
2. <число> ::= 1
3. <число> ::= <число> 0
4. <число> ::= <число> 1
5. <1число> ::= 1<число>
6. <1число> ::= 1

### Процесс составления цепочки
 <1число> -5→ 1< x<число> -3→ 1<число>0 -1→ 100
 
# Иерархия языка

## Контекстно-свободные грамматики 
(КС-грамматики)
Context-free grammar
`<x> ::= цепочка VT ∪ NV`
Слева - только один нетерминальный символ

## Контекстно-зависимые грамматики 
(КЗ-грамматики)
Context-sensitive

`a<A>b ::= b<A>a`
Нет ограничений на левую часть

### Пример

`S → ... → aba<A>bb<A> → abb<A>ab<A>

## Регулярные грамматики

### Леворегулярные грамматики

Цепочка, которая стоит в правый части может содержать нетерминальный символ только слева:  `<A>::=<B>abc`
`<A> ::= abc<B>` - так нельзя, толко в праворегулярной грамматике.

### Пример праворегулярной грамматики

```c
void f() {
	x = x + 1; // a <A> ::= abc<A>
	y = y + 2; // b
	f();
}
```

```c
void f() {
	while(1) {
		x = x + 1; 
		y = y + 2; 
	}
}
```

Гедель, Эдер, Бах - о рекурсии и циклах

 https://yadi.sk/i/UzwyLm6YgmlAkA
 
# Вторая практика
 
# Лексический анализ
 
## Лексемы/token
 
 `int` `<пробел> ` `x5` `+=` `y18` `+` `645` `;` - всё лексемы.
 
## Правила для примера
VT = {0, 1, ..., 9,  .}
 
VN = {<число>, <цифра>, <др. число>}
 
S = <др.число>
 
1. <цифра> ::= 0
2. <цифра> ::= 1
 
...
 
10. <цифра> ::= 9
11. <число> ::= <цифра>
12. <число> ::= <число><цифра>
 
### Пример цепочки вывода
<число> -12→ **<число>**<цифра> -12→ **<число>**<цифра><цифра> -11→ **<цифра>**<цифра><цифра> -2→ 1<цифра><цифра> -9→ 19<цифра> -1→ 190.
 
БНФ - Нормальная форма Бэкуса
 
Благодаря этому правилу можно объединить правила 1-10. Получится <цифра> ::= 0|1|...|8|9 [правило 1]. Получается метасимвол. 

11-12 также можно объединить в <число> ::= <цифра> | <число><цифра> [правило 2]
 
### Обновлённые правила
 
1. <цифра> ::= 0|1|...|8|9
2. <число> ::= <цифра> | <число><цифра>
3. <др. число> ::= <число>.<число> | <число>. | .<число> 

### Примеры правильных и неправильных идентификаторов

- Правильно: `xy511`, `x`, `x_5`, `_1`, `_`;

- Неправильно: `1z`, `12`.

#### Придумываем правила для идентификаторов

VT = {a, b, ..., z, A, B, ..., Z, 0, 1, ... 9}

VN = {<ид>}

S = <ид>

P:
1. <буква> ::= a|b|...|z|A|B|..|Z|_
2. <цифра> ::= 0|1|...|9
3. <ид> ::= <буква>
4. <ид> ::= <ид><буква>
5. <ид> ::= <ид><цфира>

РБНФ - расширенная нормальная форма Бэкуса

- <цифра>+ ≥ 1 раза
- <цифра>* или {<цфира>}: ≥ 0 раз
- <цифра>? или [<цфира>]: 0 или 1 раз

3-5 → [3] <ид> ::= <буква>(<буква> | <цифра>)*

#### Абстрактный пример рекурсии

```
<x> ::= <y>*
		↑ ↓
<x> ::= ε
<x> ::= <x><y>
```

### Вернулись к регулярной грамматике

\<x> ::= abc<y>

\<y> ::= de<x>

\<x> ::= ε

---
\<x> ::= abcde<x>

\<x> ::= ε

---
\<y> ::= abcde

\<x> ::= <y>*

---
\<x> ::= (abcde)*

## Пишем программку

### Референс к правилам
[a-z] - все символы от `a` до `z`

Аналогично с [A-Z]

[A-Za-z_] = <буква>

[0-9]


# Грамматика

`+ * ? ( ) |`

VT = {...}

VN = {\<S>}

P: \<S> ::= ... - VT + мета-символы = регулярные выражение

[https://yadi.sk/i/ZV5nWneKtfhcMg]

# Пример лексического анализатора

15 * (3 + 2) - x

1 + 2

10++ - выражение неправильное

## Разбивание текста не лексемы

```
10+20
↑
```

1. NUMBER, "10"

```
10+20
  ↑
```

2. ADD, "+"

```
10+20
   ↑
```

3. NUMBER, "20"

```java
enum TokenType {
	NUMBER("<...>"),
	ID("<...>"),
	ADD("\\+"),
	SUB("-"),
	MUL("\\*"),
	DIV("/"),
	LPAR("\\("),
	RPAR("\\)"),
	SPACE("[ \t\r\n]+"); // \r - для Windows.
	Pattern pattern;
	
	TokenType(String regexp) {
		pattern = Pattern.compile(regexp);
	} 
}

class Token {
	TokenType type;
	String text;
	int index;
	
	<конструктор>
}

class Lexer {
	String src;
	int pos = 0;
	List<Token> tokens = new ArrayList<>();
	boolean nextToken() {
		if (pos >= src.length()) {
			return false;
		}
		
		for (TokenType tt: TokenType.values()) {
			Matcher m = tt.pattern.matcher(src);
			m.region(pos, src.length());
			
			if (m.lookingAt()) {
				Token t = new Token (tt, m.group(), pos);
				token add(t);
				pos = m.end();
				return true;
			}
		}
		throw new RuntimeException("Неизвестный символ");
	}
	
	Lit<Token> lex() {
		while (nextToken()) {
		}
		return tokens;
	}
	
	private static void main() {
		String text = "10 + 20";
		Lexer l = new Lexer(text);
		List<Token> tlist = l.lex(); 
		for (Token t: tlist) {
			 System.out.print(t.type + " " + t.text);
		}
	}
}
```


	
  